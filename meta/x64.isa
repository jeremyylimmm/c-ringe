#instructions

0 = add32_rr 0, 1;
0 = sub32_rr 0, 1;
0 = mul32_rr 0, 1;

edx, eax = cdq eax;
eax = idiv_r 0, edx, eax;

0 = add32_ri 0, "(uint64_t)x" : "uint32_t x";
0 = kill32;

0 = mov32_ri "(uint64_t)x" : "uint32_t x";
0 = mov32_rm "(uint64_t)loc" : "alloca_t* loc";

0 = mov32_rr 1;

_ = mov32_mr "(uint64_t)loc", 0 : "alloca_t* loc";
_ = mov32_mi "make_mov32_mi_data(g, loc, i)" : "alloca_t* loc", "uint32_t i";

_ = ret;

#patterns

constant:x() -> mov32_ri("get_const_32(x)")

null() -> kill32()

add(l, r) -> add32_rr(l, r)
sub(l, r) -> sub32_rr(l, r)
mul(l, r) -> mul32_rr(l, r)
sdiv(l, r) -> idiv32_rr(l, r)

add(l, constant:r()) -> add32_ri(l, "get_const_32(r)")
add(constant:l(), r) -> add32_ri(r, "get_const_32(l)")

store(c, m, a, v) -> mov32_mr(c, m, a, v)
store(c, m, a, constant:x()) -> mov32_mi(c, m, a, "get_const_32(x)")

load(c, m, a) -> mov32_rm(c, m, a)

end(c, m, v) -> end32(c, m, v)