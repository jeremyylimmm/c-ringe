#instructions

0 = add32_rr 0, 1; "add {R32(inst->reads[0]):s}, {R32(inst->reads[1]):s}"
0 = sub32_rr 0, 1; "sub {R32(inst->reads[0]):s}, {R32(inst->reads[1]):s}"
0 = mul32_rr 0, 1; "mul {R32(inst->reads[0]):s}, {R32(inst->reads[1]):s}"

edx, eax = cdq eax; "cdq"
eax = idiv_r 0, edx, eax; "idiv {R32(inst->reads[0]):s}"

0 = add32_ri 0, "(uint64_t)x" : "uint32_t x"; "add {R32(inst->reads[0]):s}, {(uint32_t)inst->data:u}"
0 = kill32; "kill32 {R32(inst->writes[0]):s}"

0 = mov32_ri "(uint64_t)x" : "uint32_t x"; "mov {R32(inst->writes[0]):s}, {(uint32_t)inst->data:u}"
0 = mov32_rm "(uint64_t)loc" : "alloca_t* loc"; "mov {R32(inst->writes[0]):s}, [{ALLOCA((alloca_t*)inst->data):s}]"

0 = mov32_rr 1; "mov {R32(inst->writes[0]):s}, {R32(inst->reads[0]):s}"

_ = mov32_mr "(uint64_t)loc", 0 : "alloca_t* loc"; "mov [{ALLOCA((alloca_t*)inst->data):s}], {R32(inst->reads[0]):s}"
_ = mov32_mi "make_mov32_mi_data(g, loc, i)" : "alloca_t* loc", "uint32_t i"; "mov [{ALLOCA(((mov32_mi_data_t*)inst->data)->loc):s}], {((mov32_mi_data_t*)inst->data)->i:u}"

_ = ret; "ret"

_ = test32 0, 1; "test {R32(inst->reads[0]):s}, {R32(inst->reads[1]):s}"
_ = jz "(uint64_t)loc" : "machine_block_t* loc"; "jz bb_{((machine_block_t*)inst->data)->id:u}"
_ = jmp "(uint64_t)loc" : "machine_block_t* loc"; "jmp bb_{((machine_block_t*)inst->data)->id:u}"





#nodes

add32_rr(left, right);
sub32_rr(left, right);
mul32_rr(left, right);
idiv32_rr(left, right);

kill32();

mov32_ri() {"uint32_t", "value"} : "uint32_t value";
add32_ri(left) {"uint32_t", "right"} : "uint32_t right";
mov32_mr(ctrl, mem, address, value) (is_pinned, produces_memory);
mov32_mi(ctrl, mem, address) {"uint32_t", "value"} : "uint32_t value" (is_pinned, produces_memory);

mov32_rm(ctrl, mem, address) (reads_memory);

end32(ctrl, mem, value) (is_cfg, is_pinned);

branch32(ctrl, predicate) (is_cfg, is_pinned);





#patterns

constant:x() -> mov32_ri("get_const_32(x)")

null() -> kill32()

add(l, r) -> add32_rr(l, r)
sub(l, r) -> sub32_rr(l, r)
mul(l, r) -> mul32_rr(l, r)
sdiv(l, r) -> idiv32_rr(l, r)

add(l, constant:r()) -> add32_ri(l, "get_const_32(r)")
add(constant:l(), r) -> add32_ri(r, "get_const_32(l)")

store(c, m, a, v) -> mov32_mr(c, m, a, v)
store(c, m, a, constant:x()) -> mov32_mi(c, m, a, "get_const_32(x)")

load(c, m, a) -> mov32_rm(c, m, a)

end(c, m, v) -> end32(c, m, v)

branch(c, p) -> branch32(c, p)